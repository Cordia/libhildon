<!-- ##### SECTION Title ##### -->
HildonGrid

<!-- ##### SECTION Short_Description ##### -->
#HildonGrid is intended to be used where ever a number of single tap
activatable items need to be presented (e.g. Control Panel applets).

<!-- ##### SECTION Long_Description ##### -->
<para>
HildonGrid is a set of application-defineable items that are presented in a
table. The form of this table is selected from two modes; large icon mode and
small icon mode.

In large icon mode, the Grid View items are presented with a large icon and a
label underneath it. In small icon mode, the items are presented with a small
icon and a label on the right side of the icon.

The label of an item is displayed within a band of colour displayed as a
background colour as wide as the maximum text width. This allows the text to
have focus as well as be legible when displayed upon a black or dark background
image. Long names are truncated with an ellipsis ("...") appended.
</para>

<para>
<informalexample>
Example:
<programlisting>
<!-- hildon-tests/wt/hildon-widgets-combo/testgrid.c -->
##include &lt;hildon-widgets/hildon-app.h&gt;
##include &lt;hildon-widgets/hildon-appview.h&gt;
##include &lt;hildon-widgets/hildon-grid.h&gt;
##include &lt;hildon-widgets/hildon-grid-item.h&gt;
##include &lt;gtk/gtk.h&gt;
##include &lt;pango/pango.h&gt;
##include &lt;libintl.h&gt;
##include &lt;locale.h&gt;
##include &lt;string.h&gt;
##include &lt;gtk/gtktoolbar.h&gt;
##include &lt;gtk/gtkwidget.h&gt;

##ifdef HAVE_CONFIG_H
##include &lt;config.h&gt;
##endif

##include &lt;stdio.h&gt;
##include &lt;stdlib.h&gt;

##define _(String) gettext (String)

##define ICONFILE    "Help"

enum {
	ACTIVATE,
	DISABLE_NEXT,
	EMBLEM_NEXT
};

static int action = ACTIVATE;


static GtkWidget    *w_add_one = NULL;
static GtkWidget    *w_add_eight = NULL;
static GtkWidget    *w_disable_next = NULL;
static GtkWidget    *w_emblem_next = NULL;

static GtkWidget    *menu_small_icons;
static GtkWidget    *menu_big_icons;

static GtkWidget    *standard_icons;
static GtkWidget    *alt_empty_label;
static GtkWidget    *dim_selected;
static GtkWidget    *undim_all;


GtkWidget *create_layout(void);
static void activate (HildonGrid *grid, HildonGridItem *item, gpointer data);
static void generate_name (char *target, size_t len);
static void update_dim (HildonGrid *grid);

static void add_one (HildonGrid *grid);
static void add_eight (HildonGrid *grid);
static void disable_this (GtkWidget *widget);
static void emblem_this (GtkWidget *widget);

static void create_basic_icons (HildonGrid *grid);
static void remove_all_icons (HildonGrid *grid);
static void show_standard_icons_signal (GtkMenuItem *widget, gpointer data);
static void set_empty_label_signal (GtkMenuItem *widget, gpointer data);
static void dim_selected_signal (GtkMenuItem *widget, gpointer data);
static void undim_all_signal (GtkMenuItem *widget, gpointer data);
static void set_icon_size (GtkMenuItem *item, gpointer data);

void _testGrid(GtkWidget *parent, gchar **help);

void
_testGrid(GtkWidget *parent, gchar **help)
{

	GtkIconTheme *icon_theme;
	GtkWidget *grid;
	GtkWidget *popup;
	GtkMenu *menu;
	GSList *group = NULL;

	icon_theme = gtk_icon_theme_get_default ();

	grid = create_layout ();
	gtk_container_add (GTK_CONTAINER (parent), grid);

	g_signal_connect (grid, "activate-child", G_CALLBACK (activate), NULL);

	/* Create context menu. */
	popup = gtk_menu_new ();
	menu_small_icons = gtk_radio_menu_item_new_with_label (group,
			_("Small icons"));
	menu_big_icons = gtk_radio_menu_item_new_with_label (
			gtk_radio_menu_item_get_group (
				GTK_RADIO_MENU_ITEM (menu_small_icons)),
			_("Big icons"));
	gtk_check_menu_item_set_active (GTK_CHECK_MENU_ITEM (menu_big_icons),
			TRUE);

	gtk_widget_show (menu_small_icons);
	gtk_widget_show (menu_big_icons);
	gtk_menu_shell_append (GTK_MENU_SHELL (popup), menu_small_icons);
	gtk_menu_shell_append (GTK_MENU_SHELL (popup), menu_big_icons);
	gtk_widget_tap_and_hold_setup (grid, popup, NULL, TRUE);

	g_signal_connect (G_OBJECT (menu_small_icons), "activate",
			G_CALLBACK (set_icon_size), HILDON_GRID (grid));
	g_signal_connect (G_OBJECT (menu_big_icons), "activate",
			G_CALLBACK (set_icon_size), HILDON_GRID (grid));

	/* Add menuitem for showing/hiding standard icons. */
	menu = hildon_appview_get_menu (HILDON_APPVIEW (
				gtk_widget_get_ancestor (parent, HILDON_TYPE_APPVIEW)));
	standard_icons = gtk_check_menu_item_new_with_label (
			_("Show standard icons"));
	gtk_check_menu_item_set_active (GTK_CHECK_MENU_ITEM (standard_icons), TRUE);
	alt_empty_label = gtk_check_menu_item_new_with_label (
			_("Alternative empty label"));
	gtk_check_menu_item_set_active (GTK_CHECK_MENU_ITEM (alt_empty_label),
			FALSE);

	dim_selected = gtk_menu_item_new_with_label (_("Dim current"));
	undim_all = gtk_menu_item_new_with_label (_("Undim all"));


	gtk_menu_shell_append (GTK_MENU_SHELL (menu), standard_icons);
	gtk_widget_show (standard_icons);
	gtk_menu_shell_append (GTK_MENU_SHELL (menu), alt_empty_label);
	gtk_widget_show (alt_empty_label);
	gtk_menu_shell_append (GTK_MENU_SHELL (menu), dim_selected);
	gtk_widget_show (dim_selected);
	gtk_menu_shell_append (GTK_MENU_SHELL (menu), undim_all);
	gtk_widget_show (undim_all);

	g_signal_connect (G_OBJECT (standard_icons), "toggled",
			G_CALLBACK (show_standard_icons_signal),
			(gpointer) grid);
	g_signal_connect (G_OBJECT (alt_empty_label), "toggled",
			G_CALLBACK (set_empty_label_signal),
			(gpointer) grid);
	g_signal_connect (G_OBJECT (dim_selected), "activate",
			G_CALLBACK (dim_selected_signal),
			(gpointer) grid);
	g_signal_connect (G_OBJECT (undim_all), "activate",
			G_CALLBACK (undim_all_signal),
			(gpointer) grid);

	create_basic_icons (HILDON_GRID (grid));
	update_dim (HILDON_GRID (grid));

	hildon_grid_set_style (HILDON_GRID (grid), "bigicons");
	gtk_widget_show (GTK_WIDGET (grid));

}

static void
show_standard_icons_signal (GtkMenuItem *widget,
                            gpointer    data)
{
	HildonGrid *grid;
	grid = HILDON_GRID (data);

	if (gtk_check_menu_item_get_active (GTK_CHECK_MENU_ITEM (widget)))
		create_basic_icons (grid);
	else
		remove_all_icons (grid);

	update_dim (grid);
}

static void
set_empty_label_signal (GtkMenuItem *widget,
                        gpointer    data)
{
	GValue val = {0, };
	HildonGrid *grid;
	grid = HILDON_GRID (data);

	g_value_init (&amp;val, G_TYPE_STRING);

	if (gtk_check_menu_item_get_active (GTK_CHECK_MENU_ITEM (widget)))
		g_value_set_string (&amp;val, _("Alternative empty label here"));
	else
		g_value_set_string (&amp;val, _("No icons"));

	g_object_set_property (G_OBJECT (grid), "empty_label", &amp;val);
}

static void
create_basic_icons (HildonGrid *grid)
{
	w_add_one = hildon_grid_item_new_with_label (
			"Calendar", _("Add one"));
	w_add_eight = hildon_grid_item_new_with_label (
			"Clock", _("Add eight"));
	w_disable_next = hildon_grid_item_new_with_label (
			"Calculator", _("Disable next"));
	w_emblem_next = hildon_grid_item_new_with_label (
			"Paint", _("Set emblem"));
	emblem_this (w_emblem_next);

	gtk_container_add (GTK_CONTAINER (grid), w_add_one);
	gtk_container_add (GTK_CONTAINER (grid), w_add_eight);
	gtk_container_add (GTK_CONTAINER (grid), w_disable_next);
	gtk_container_add (GTK_CONTAINER (grid), w_emblem_next);
}

static void
remove_all_icons (HildonGrid *grid)
{
	gtk_container_remove (GTK_CONTAINER (grid), w_add_one);
	gtk_container_remove (GTK_CONTAINER (grid), w_add_eight);
	gtk_container_remove (GTK_CONTAINER (grid), w_disable_next);
	gtk_container_remove (GTK_CONTAINER (grid), w_emblem_next);
}

static void
generate_name (gchar *target, size_t len)
{
	int i;
	target[len] = '\0';
	for (i = 0; i &lt; len; i++)
		target[i] = (rand() &amp; 0x0f) + 'a';
}


GtkWidget *
create_layout (void)
{
	GtkWidget *grid;
	grid = hildon_grid_new ();
	return GTK_WIDGET (grid);
}

static void
activate (HildonGrid *grid, HildonGridItem *item, gpointer data)
{
	GtkWidget *widget;
	widget = GTK_WIDGET (item);

	switch (action)
	{
		case ACTIVATE:
			if (widget == w_add_one)
				add_one (grid);
			else if (widget == w_add_eight)
				add_eight (grid);
			else if (widget == w_disable_next)
				action = DISABLE_NEXT;
			else if (widget == w_emblem_next)
				action = EMBLEM_NEXT;
			else
			{
				gtk_container_remove (GTK_CONTAINER (grid), widget);
				update_dim (grid);
			}
			break;

		case DISABLE_NEXT:
			disable_this (widget);
			action = ACTIVATE;
			break;

		case EMBLEM_NEXT:
			emblem_this (widget);
			action = ACTIVATE;
			break;
	}
}

static void
add_one (HildonGrid *grid)
{
#define LABEL_WIDTH 64
	static gchar foo[LABEL_WIDTH];
	GtkWidget *t;
	generate_name (foo, rand () % (LABEL_WIDTH - 1) + 1);
	t = hildon_grid_item_new_with_label (ICONFILE, foo);
	gtk_container_add (GTK_CONTAINER (grid), t);
	gtk_widget_show (t);

	update_dim (grid);
}

static void
add_eight (HildonGrid *grid)
{
	int i;
	for (i = 0; i &lt; 8; i++)
		add_one (grid);
}

static void
emblem_this (GtkWidget *widget)
{
	const char *emblem;
	emblem = hildon_grid_item_get_emblem_type (HILDON_GRID_ITEM (widget));

	hildon_grid_item_set_emblem_type (HILDON_GRID_ITEM (widget),
			emblem == NULL ? "gnome-mime-image-png" : NULL);
}
	
static void
disable_this (GtkWidget *widget)
{
	gtk_widget_set_sensitive (widget, FALSE);
}

static void
dim_selected_signal (GtkMenuItem    *widget,
                     gpointer       data)
{
	GtkWidget *selected;

	selected = GTK_CONTAINER (data)-&gt;focus_child;
	gtk_widget_set_sensitive (selected, FALSE);
}

static void
undim_all_signal (GtkMenuItem   *widget,
                  gpointer      data)
{
	gtk_container_foreach (GTK_CONTAINER (data),
			(GtkCallback) gtk_widget_set_sensitive,
			(gpointer) TRUE);
}

static void
update_dim (HildonGrid *grid)
{
	GtkWidget *selected;
	selected = GTK_CONTAINER (grid)-&gt;focus_child;
	gtk_widget_set_sensitive (dim_selected, selected != NULL);
}

static void
set_icon_size (GtkMenuItem *item, gpointer data)
{
	HildonGrid *grid;
	grid = HILDON_GRID (data);

	if (GTK_WIDGET (item) == menu_small_icons)
		hildon_grid_set_style (grid, "smallicons");
	else if (GTK_WIDGET (item) == menu_big_icons)
		hildon_grid_set_style (grid, "bigicons");
} 
</programlisting>
</informalexample>
</para>

<!-- ##### SECTION See_Also ##### -->
<para>
#HildonGridItem
</para>

<!-- ##### FUNCTION hildon_grid_new ##### -->
<para>

</para>

@Returns: 


<!-- ##### FUNCTION hildon_grid_set_style ##### -->
<para>

</para>

@grid: 
@style_name: 


<!-- ##### FUNCTION hildon_grid_get_style ##### -->
<para>

</para>

@grid: 
@Returns: 


<!-- ##### FUNCTION hildon_grid_set_scrollbar_pos ##### -->
<para>

</para>

@grid: 
@scrollbar_pos: 


<!-- ##### FUNCTION hildon_grid_get_scrollbar_pos ##### -->
<para>

</para>

@grid: 
@Returns: 


<!-- ##### FUNCTION hildon_grid_activate_child ##### -->
<para>

</para>

@grid: 
@item: 


<!-- ##### SIGNAL HildonGrid::activate-child ##### -->
<para>

</para>

@hildongrid: the object which received the signal.
@arg1: 

<!-- ##### SIGNAL HildonGrid::popup-context-menu ##### -->
<para>

</para>

@hildongrid: the object which received the signal.
@arg1: 
@arg2: 
@arg3: 
@Returns: 

<!-- ##### ARG HildonGrid:empty-label ##### -->
<para>

</para>

<!-- ##### ARG HildonGrid:emblem-size ##### -->
<para>

</para>

<!-- ##### ARG HildonGrid:icon-size ##### -->
<para>

</para>

<!-- ##### ARG HildonGrid:item-height ##### -->
<para>

</para>

<!-- ##### ARG HildonGrid:item-hspacing ##### -->
<para>

</para>

<!-- ##### ARG HildonGrid:item-vspacing ##### -->
<para>

</para>

<!-- ##### ARG HildonGrid:item-width ##### -->
<para>

</para>

<!-- ##### ARG HildonGrid:label-height ##### -->
<para>

</para>

<!-- ##### ARG HildonGrid:label-hspacing ##### -->
<para>

</para>

<!-- ##### ARG HildonGrid:label-pos ##### -->
<para>

</para>

<!-- ##### ARG HildonGrid:label-vspacing ##### -->
<para>

</para>

<!-- ##### ARG HildonGrid:n-columns ##### -->
<para>

</para>

